# US_20251213154200_01 基础角色移动 - 手把手开发指导

## 📋 任务概述

本文档提供基础角色移动功能的详细开发指导，实现玩家使用A/D键控制角色左右移动的功能。

- **Story文档**: [US_20251213154200_01 基础角色移动](../03_sprint/02_story/01_基础角色移动.md)
- **验收标准**: 6项（A/D键移动、停止、速度、朝向、动画）
- **预估工期**: 1人日
- **技术栈**: Godot 4.5 + GDScript + CharacterBody2D

---

## 🎯 第一步：Godot项目配置

### 1.1 创建输入动作映射

<font color="orange">**请在Godot编辑器中完成以下操作**：</font>

1. 打开 `项目` → `项目设置` → `输入映射`
2. 添加以下输入动作：

| 动作名称 | 物理按键 | 说明 |
|---------|---------|------|
| `move_left` | A键 | 向左移动 |
| `move_right` | D键 | 向右移动 |

**操作步骤**：
- 在"添加新动作"输入框中输入 `move_left`，点击添加
- 点击 `move_left` 右侧的"+"号
- 选择"物理按键"，找到并选择A键
- 重复以上步骤创建 `move_right` 并绑定D键

---

## 🎮 第二步：创建玩家场景结构

### 2.1 创建场景文件

<font color="orange">**请在Godot编辑器中创建场景文件**：</font>

1. 在 `scenes` 文件夹下创建 `characters` 子文件夹
2. 在 `scenes/characters/` 中创建新场景：
   - 根节点类型：`CharacterBody2D`
   - 保存为：`player.tscn`

### 2.2 添加节点层级

<font color="orange">**请在player.tscn场景中按以下顺序添加节点**：</font>

```
Player (CharacterBody2D)
├── CollisionShape2D        # 碰撞检测
├── Sprite2D               # 角色精灵显示
├── AnimationPlayer        # 动画控制
└── PlayerStateMachine     # 状态机（Node类型）
```

**详细步骤**：
1. 选择 `Player` 根节点
2. 添加子节点：`CollisionShape2D`
   - 在检查器中，Shape属性选择 `New CapsuleShape2D`
   - 调整胶囊形状大小以匹配角色大小
3. 添加子节点：`Sprite2D`
   - 在检查器中，Texture属性设置为角色精灵图（knight.png）
4. 添加子节点：`AnimationPlayer`
5. 添加子节点：`Node`，重命名为 `PlayerStateMachine`

---

## 📝 第三步：创建脚本文件框架

### 3.1 创建脚本文件

<font color="orange">**请在对应的文件夹中创建以下脚本文件**：</font>

1. **player.gd** - 主角色控制器
   - 路径：`scripts/characters/player.gd`
   - 附加到：Player节点

2. **player_state_machine.gd** - 状态机管理器
   - 路径：`scripts/characters/player_state_machine.gd`
   - 附加到：PlayerStateMachine节点

3. **player_state.gd** - 状态基类
   - 路径：`scripts/characters/states/player_state.gd`

4. **idle_state.gd** - 空闲状态
   - 路径：`scripts/characters/states/idle_state.gd`

5. **walk_state.gd** - 行走状态
   - 路径：`scripts/characters/states/walk_state.gd`

### 3.2 附加脚本到节点

<font color="orange">**请在Godot编辑器中完成脚本附加**：</font>

1. 选择 `Player` 节点，附加 `player.gd` 脚本
2. 选择 `PlayerStateMachine` 节点，附加 `player_state_machine.gd` 脚本

---

## 🔧 第四步：编写脚本框架代码

### 4.1 Player.gd - 主角色控制器

<font color="orange">**请创建以下脚本文件，但先不要填写实现代码**：</font>

```gdscript
# scripts/characters/player.gd
class_name Player
extends CharacterBody2D

# 导出变量 - 在检查器中可配置
@export var move_speed: float = 300.0
@export var acceleration: float = 1000.0
@export var friction: float = 1000.0

# 节点引用 - @onready 会在节点准备好后自动赋值
@onready var sprite: Sprite2D = $Sprite2D
@onready var animation_player: AnimationPlayer = $AnimationPlayer
@onready var state_machine: PlayerStateMachine = $PlayerStateMachine

# 初始化
func _ready() -> void:
    # TODO: 初始化状态机
    pass

# 物理更新 - 每帧调用，处理物理相关逻辑
func _physics_process(delta: float) -> void:
    # TODO: 更新状态机
    pass

# 输入处理 - 处理输入事件
func _input(event: InputEvent) -> void:
    # TODO: 传递输入给状态机
    pass

# 获取移动输入 - 返回-1(左)、0(停止)、1(右)
func handle_movement_input() -> float:
    # TODO: 实现输入检测逻辑
    return 0.0
```

### 4.2 PlayerStateMachine.gd - 状态机管理器

```gdscript
# scripts/characters/player_state_machine.gd
class_name PlayerStateMachine
extends Node

# 状态枚举定义
enum State {
    IDLE,
    WALK,
    JUMP,
    FALL
}

# 当前状态实例
var current_state: PlayerState
# 状态字典，存储所有状态实例
var states: Dictionary = {}

# 初始化
func _ready() -> void:
    # TODO: 创建所有状态实例
    # TODO: 设置初始状态为IDLE
    pass

# 物理更新 - 委托给当前状态
func _physics_process(delta: float) -> void:
    # TODO: 调用当前状态的physics_update
    pass

# 状态切换方法
func change_state(new_state: State) -> void:
    # TODO: 实现状态切换逻辑
    pass

# 获取当前状态名称（调试用）
func get_state_name() -> String:
    # TODO: 返回当前状态名称
    return ""
```

### 4.3 PlayerState.gd - 状态基类

```gdscript
# scripts/characters/states/player_state.gd
class_name PlayerState
extends Node

# 引用父节点和系统
var player: Player
var state_machine: PlayerStateMachine
var animation_player: AnimationPlayer

# 初始化 - 设置引用
func init(player_node: Player, state_machine_node: PlayerStateMachine) -> void:
    # TODO: 设置节点引用
    pass

# 虚方法 - 状态进入时调用
func enter() -> void:
    # 子类实现具体逻辑
    pass

# 虚方法 - 状态退出时调用
func exit() -> void:
    # 子类实现具体逻辑
    pass

# 虚方法 - 每帧更新
func update(delta: float) -> void:
    # 子类实现具体逻辑
    pass

# 虚方法 - 物理更新
func physics_update(delta: float) -> void:
    # 子类实现具体逻辑
    pass

# 虚方法 - 输入处理
func handle_input(event: InputEvent) -> void:
    # 子类实现具体逻辑
    pass
```

### 4.4 IdleState.gd - 空闲状态

```gdscript
# scripts/characters/states/idle_state.gd
class_name IdleState
extends PlayerState

# 状态进入
func enter() -> void:
    # TODO: 播放idle动画
    pass

# 状态退出
func exit() -> void:
    # TODO: 清理状态相关逻辑
    pass

# 物理更新
func physics_update(delta: float) -> void:
    # TODO: 检查是否需要切换到行走状态
    pass

# 输入处理
func handle_input(event: InputEvent) -> void:
    # TODO: 处理状态相关输入
    pass

# 检查行走状态转换
func check_walk_transition() -> void:
    # TODO: 实现到WalkState的转换条件
    pass
```

### 4.5 WalkState.gd - 行走状态

```gdscript
# scripts/characters/states/walk_state.gd
class_name WalkState
extends PlayerState

# 状态进入
func enter() -> void:
    # TODO: 播放walk动画
    pass

# 状态退出
func exit() -> void:
    # TODO: 清理状态相关逻辑
    pass

# 物理更新
func physics_update(delta: float) -> void:
    # TODO: 处理移动逻辑
    # TODO: 检查是否需要切换到空闲状态
    pass

# 输入处理
func handle_input(event: InputEvent) -> void:
    # TODO: 处理状态相关输入
    pass

# 检查空闲状态转换
func check_idle_transition() -> void:
    # TODO: 实现到IdleState的转换条件
    pass

# 更新动画
func update_animation() -> void:
    # TODO: 根据移动状态更新动画
    pass

# 更新精灵朝向
func update_sprite_direction(input_direction: float) -> void:
    # TODO: 根据移动方向翻转精灵
    pass
```

---

## 🎨 第五步：准备动画资源

### 5.1 创建动画

<font color="orange">**请在AnimationPlayer中创建以下动画**：</font>

1. 选择 `AnimationPlayer` 节点
2. 在动画面板中创建动画：
   - 动画名称：`idle`（待机动画）
   - 动画名称：`walk`（行走动画）

3. 为每个动画设置关键帧：
   - idle动画：单帧或循环待机动作
   - walk动画：多帧行走动作循环

### 5.2 设置动画属性

<font color="orange">**请在检查器中配置动画属性**：</font>

1. 选择 `walk` 动画
2. 设置动画循环：`Loop` 选项勾选
3. 设置动画播放速度：根据需要调整

---

## ⚡ 第六步：测试验证步骤

### 6.1 基础功能测试

<font color="orange">**请按以下步骤验证功能**：</font>

1. **运行场景**
   - 点击Godot编辑器右上角的"播放"按钮
   - 或按F5运行当前场景

2. **测试移动控制**
   - 按A键：角色应该向左移动
   - 按D键：角色应该向右移动
   - 同时按A和D：角色应该停止
   - 松开所有键：角色应该停止

3. **验证移动速度**
   - 观察角色移动速度是否约为300像素/秒

4. **检查角色朝向**
   - 向左移动时，角色应该面向左侧
   - 向右移动时，角色应该面向右侧

5. **验证动画播放**
   - 静止时播放idle动画
   - 移动时播放walk动画
   - 停止时切换回idle动画

### 6.2 调试输出

<font color="orange">**如需调试，可以在脚本中添加临时输出**：</font>

```gdscript
# 在需要调试的地方添加
print("当前状态：", state_machine.get_state_name())
print("输入方向：", input_direction)
print("速度：", velocity.x)
```

---

## 📊 第七步：验收标准检查清单

### 7.1 功能验收

请逐项确认以下验收标准：

- [ ] **AC1**: 按下A键时，角色向左移动
- [ ] **AC2**: 按下D键时，角色向右移动
- [ ] **AC3**: 同时按下A和D键或都不按时，角色停止移动
- [ ] **AC4**: 移动速度保持在300像素/秒
- [ ] **AC5**: 移动过程中角色朝向与移动方向一致
- [ ] **AC6**: 角色移动时有对应的行走动画

### 7.2 性能验收

- [ ] 游戏运行在60FPS，无明显卡顿
- [ ] 内存使用正常，无明显泄漏
- [ ] 响应延迟小于16ms（1帧）

---

## 🐛 第八步：常见问题排查

### 8.1 移动无响应

**可能原因**：
- 输入映射未正确设置
- 脚本未正确附加到节点
- 状态机未正确初始化

**解决方法**：
1. 检查项目设置中的输入映射
2. 确认脚本已附加到对应节点
3. 添加调试输出确认代码执行

### 8.2 动画不播放

**可能原因**：
- 动画名称不匹配
- AnimationPlayer节点引用错误
- 动画未设置为循环

**解决方法**：
1. 检查动画名称是否为"idle"和"walk"
2. 确认@onready变量正确获取节点引用
3. 设置walk动画的Loop属性

### 8.3 角色朝向错误

**可能原因**：
- sprite.flip_h逻辑错误
- 输入方向判断错误

**解决方法**：
1. 检查update_sprite_direction方法实现
2. 确认输入方向值的正负号正确

---

## 🎯 第九步：后续扩展准备

### 9.1 为跳跃功能预留接口

当前状态机设计已为跳跃功能预留：
- `JUMP` 状态枚举
- `JumpState` 类继承结构
- 状态切换方法

### 9.2 为其他功能预留扩展点

- 音效系统：在状态进入/退出时添加音效
- 粒子效果：在移动时添加拖尾效果
- 输入缓冲：为实现更好的手感预留接口

---

## 📝 第十步：代码实现指导

<font color="orange">**当您准备好实现具体代码时，请按照以下优先级顺序**：</font>

1. **第一优先级**：实现基础移动逻辑
   - Player.gd中的handle_movement_input方法
   - PlayerStateMachine.gd中的状态管理
   - IdleState和WalkState的状态转换

2. **第二优先级**：实现动画和朝向
   - WalkState中的update_animation方法
   - WalkState中的update_sprite_direction方法

3. **第三优先级**：优化和调试
   - 添加调试输出
   - 性能优化
   - 错误处理

---

## 🎮 开发完成

恭喜！按照以上指导，您将成功实现基础角色移动功能。这个实现完全遵循游戏架构设计中的状态机模式，为后续功能的扩展奠定了坚实的基础。

**下一步建议**：
- 实现跳跃功能（JumpState）
- 添加音效系统
- 实现踩踏攻击功能

**注意事项**：
- 所有TODO标记都是需要您手动实现的部分
- 请严格按照架构设计进行扩展
- 保持代码风格一致性

祝您开发顺利！ 🎉