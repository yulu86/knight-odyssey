# KO_20251216_011 游戏管理器核心框架 TDD开发指导

## 文档信息
- **Story ID**: KO_20251216_011
- **Story标题**: 游戏管理器核心框架
- **优先级**: P0（最高优先级）
- **预估工作量**: 8个Story点（4天）
- **开发方法**: TDD（测试驱动开发）
- **文档版本**: 1.0
- **创建日期**: 2025-12-21

---

## 1. 项目概述

### 1.1 需求描述
作为游戏开发者，需要一个统一的游戏管理框架来协调各个系统之间的交互和管理游戏状态。

### 1.2 验收标准
- 游戏启动时，GameManager应初始化所有子系统
- 场景切换时，GameManager应协调资源加载和释放
- 触发游戏事件时，EventBus应正确分发事件到订阅者
- 需要配置参数时，ConfigManager应从文件加载配置
- 保存进度时，GameManager应调用相应的管理器保存数据
- 所有管理器使用AutoLoad机制，全局可访问
- 系统间通过事件解耦，避免直接依赖

### 1.3 技术要求
- Godot 4.5
- GDScript
- AutoLoad单例模式
- 基于事件驱动的松耦合架构
- GUT测试框架

---

## 2. 架构设计

### 2.1 管理器系统架构

```
┌─────────────────┐
│   GameManager   │ ← 总控制器
└─────────┬───────┘
          │
    ┌─────┴─────┐
    │ EventBus  │ ← 事件总线（解耦通信）
    └─────┬─────┘
          │
    ┌─────┴─────┐
    │  各个管理器  │
    └───────────┘
```

### 2.2 管理器清单

| 管理器 | 职责 | 数据持久化 |
| ------ | ---- | ---------- |
| GameManager | 总控制器，协调各系统 | 否 |
| EventBus | 事件总线，解耦通信 | 否 |
| ConfigManager | 配置加载，参数管理 | ConfigFile |
| LevelManager | 关卡管理，进度保存 | ConfigFile |
| ScoreManager | 分数统计，生命奖励 | 否 |
| LifeManager | 生命值管理，游戏状态 | 否 |
| AudioManager | 音频播放，音效管理 | 否 |

### 2.3 目录结构设计

```
knight-odyssey/
├── scripts/
│   └── managers/
│       ├── game_manager.gd
│       ├── event_bus.gd
│       ├── config_manager.gd
│       ├── level_manager.gd
│       ├── score_manager.gd
│       ├── life_manager.gd
│       └── audio_manager.gd
├── test/
│   └── unit/
│       └── managers/
│           ├── test_game_manager.gd
│           ├── test_event_bus.gd
│           ├── test_config_manager.gd
│           ├── test_level_manager.gd
│           ├── test_score_manager.gd
│           ├── test_life_manager.gd
│           └── test_audio_manager.gd
├── scenes/
│   └── managers/
│       └── manager_test_scene.tscn
└── configs/
    ├── game_config.cfg
    ├── audio_config.cfg
    └── level_config.cfg
```

---

## 3. 实施计划

### 3.1 开发阶段

#### 阶段1：核心框架（AI助手 - 2天）
1. EventBus事件总线系统
2. ConfigManager配置管理系统
3. GameManager游戏管理器基础功能

#### 阶段2：业务管理器（用户 - 1.5天）
1. ScoreManager分数管理器
2. LifeManager生命管理器
3. LevelManager关卡管理器

#### 阶段3：增强功能（AI助手 - 0.5天）
1. AudioManager音频管理器
2. AutoLoad配置
3. 集成测试

### 3.2 TDD开发流程

每个管理器都将遵循严格的TDD流程：
1. **Red**: 编写失败的测试用例
2. **Green**: 实现最小功能使测试通过
3. **Refactor**: 重构优化代码
4. **Repeat**: 重复循环直到功能完整

---

## 4. 详细实施步骤

### 第1步：EventBus事件总线系统

#### 4.1.1 责任人
**AI助手**

#### 4.1.2 测试用例设计（Red阶段）

创建文件：`test/unit/managers/test_event_bus.gd`

```gdscript
extends GutTest

func before_each():
    EventBus.clear_all_listeners()

func test_event_subscription():
    # 准备：创建事件监听
    var received = false
    
    # 执行：订阅并发射事件
    EventBus.player_died.connect(func(): received = true)
    EventBus.player_died.emit()
    
    # 验证：事件被接收
    assert_true(received, "事件应该被正确接收")

func test_event_with_data():
    # 测试带数据的事件
    var score = 0
    EventBus.score_changed.connect(func(value): score = value)
    EventBus.score_changed.emit(100)
    assert_eq(score, 100, "事件数据应该正确传递")

func test_multiple_listeners():
    # 测试多个监听器
    var count = 0
    EventBus.score_changed.connect(func(): count += 1)
    EventBus.score_changed.connect(func(): count += 1)
    EventBus.score_changed.emit()
    assert_eq(count, 2, "所有监听器都应该被触发")

func test_listener_removal():
    # 测试移除监听器
    var received = false
    var listener = func(): received = true
    EventBus.player_died.connect(listener)
    EventBus.player_died.disconnect(listener)
    EventBus.player_died.emit()
    assert_false(received, "移除的监听器不应接收事件")
```

#### 4.1.3 实现框架（Green阶段）

创建文件：`scripts/managers/event_bus.gd`

```gdscript
extends Node

# 定义游戏核心事件
signal player_died
signal player_respawned
signal score_changed(new_score: int)
signal life_changed(new_lives: int)
signal level_completed(level_name: String)
signal game_paused
signal game_resumed
signal coin_collected(value: int)
signal enemy_died(enemy_type: String)

# 清理所有监听器（测试用）
static func clear_all_listeners():
    pass  # TODO: 实现清理逻辑

# 通用事件发射方法
func emit_event(event_name: String, data = null):
    pass  # TODO: 实现事件发射
```

#### 4.1.4 用户操作
1. 在Godot编辑器中创建测试文件
2. 运行测试确认失败（Red阶段）
3. 实现EventBus的最小功能
4. 运行测试确认通过（Green阶段）

---

### 第2步：ConfigManager配置管理系统

#### 4.2.1 责任人
**AI助手**

#### 4.2.2 测试用例设计

创建文件：`test/unit/managers/test_config_manager.gd`

```gdscript
extends GutTest

var test_config_path = "user://test_config.cfg"

func before_each():
    ConfigManager.config_path = test_config_path
    ConfigManager._config = ConfigFile.new()

func test_load_existing_config():
    # 测试加载现有配置
    var config = ConfigFile.new()
    config.set_value("player", "speed", 200)
    config.save(test_config_path)
    
    ConfigManager.load_config()
    assert_eq(ConfigManager.get_value("player", "speed"), 200)

func test_get_default_value():
    # 测试获取默认值
    assert_eq(ConfigManager.get_value("nonexistent", "key", "default"), "default")

func test_set_and_save_value():
    # 测试设置和保存值
    ConfigManager.set_value("test", "value", 123)
    ConfigManager.save_config()
    
    var new_config = ConfigFile.new()
    new_config.load(test_config_path)
    assert_eq(new_config.get_value("test", "value"), 123)

func test_player_config_convenience_methods():
    # 测试玩家配置便捷方法
    ConfigManager.set_value("player", "move_speed", 150.0)
    assert_eq(ConfigManager.get_player_move_speed(), 150.0)
```

#### 4.2.3 实现框架

创建文件：`scripts/managers/config_manager.gd`

```gdscript
extends Node

var _config: ConfigFile
var config_path: String = "res://configs/game_config.cfg"

func _ready():
    load_config()

# 加载配置文件
func load_config():
    pass  # TODO: 实现配置加载逻辑

# 保存配置文件
func save_config():
    pass  # TODO: 实现配置保存逻辑

# 获取配置值
func get_value(section: String, key: String, default_value = null):
    pass  # TODO: 实现值获取逻辑

# 设置配置值
func set_value(section: String, key: String, value):
    pass  # TODO: 实现值设置逻辑

# 便捷方法：获取玩家移动速度
func get_player_move_speed() -> float:
    return get_value("player", "move_speed", 150.0)

# 便捷方法：获取跳跃速度
func get_player_jump_velocity() -> float:
    return get_value("player", "jump_velocity", -320.0)
```

#### 4.2.4 配置文件模板

创建文件：`configs/game_config.cfg`

```ini
[player]
move_speed=150.0
acceleration=300.0
floor_friction=1200.0
air_friction=1800.0
jump_velocity=-320.0
is_debug=false

[game]
default_lives=3
score_per_coin=100
score_per_fruit=500
extra_life_score=1000

[audio]
bgm_volume=0.8
sfx_volume=1.0
```

#### 4.2.5 用户操作
1. 创建configs目录和配置文件
2. 创建测试文件并运行
3. 实现ConfigManager基础功能
4. 测试配置文件读写功能

---

### 第3步：GameManager游戏管理器

#### 4.3.1 责任人
**AI助手**

#### 4.3.2 测试用例设计

创建文件：`test/unit/managers/test_game_manager.gd`

```gdscript
extends GutTest

func before_each():
    GameManager.reset_game()

func test_game_initialization():
    # 测试游戏初始化
    GameManager.initialize_game()
    assert_eq(GameManager.get_game_state(), GameManager.GameState.MENU)

func test_start_new_game():
    # 测试开始新游戏
    GameManager.start_new_game()
    assert_eq(GameManager.get_game_state(), GameManager.GameState.PLAYING)
    assert_eq(LifeManager.get_lives(), 3)
    assert_eq(ScoreManager.get_score(), 0)

func test_pause_and_resume():
    # 测试暂停和恢复
    GameManager.start_new_game()
    GameManager.pause_game()
    assert_eq(GameManager.get_game_state(), GameManager.GameState.PAUSED)
    
    GameManager.resume_game()
    assert_eq(GameManager.get_game_state(), GameManager.GameState.PLAYING)

func test_game_over():
    # 测试游戏结束
    GameManager.start_new_game()
    GameManager.game_over()
    assert_eq(GameManager.get_game_state(), GameManager.GameState.GAME_OVER)

func test_restart_level():
    # 测试重启关卡
    GameManager.start_new_game()
    ScoreManager.add_score(100)
    GameManager.restart_level()
    assert_eq(ScoreManager.get_score(), 0)
    assert_eq(GameManager.get_game_state(), GameManager.GameState.PLAYING)
```

#### 4.3.3 实现框架

创建文件：`scripts/managers/game_manager.gd`

```gdscript
extends Node

enum GameState {
    MENU,
    PLAYING,
    PAUSED,
    GAME_OVER,
    LEVEL_TRANSITION
}

var current_state: GameState = GameState.MENU

func _ready():
    initialize_game()

# 初始化游戏
func initialize_game():
    pass  # TODO: 初始化所有子系统

# 开始新游戏
func start_new_game():
    pass  # TODO: 开始新游戏逻辑

# 暂停游戏
func pause_game():
    pass  # TODO: 暂停游戏逻辑

# 恢复游戏
func resume_game():
    pass  # TODO: 恢复游戏逻辑

# 游戏结束
func game_over():
    pass  # TODO: 游戏结束逻辑

# 重启游戏
func restart_game():
    pass  # TODO: 重启游戏逻辑

# 获取当前游戏状态
func get_game_state() -> GameState:
    return current_state
```

#### 4.3.4 用户操作
1. 创建GameManager测试文件
2. 实现基础状态管理
3. 测试状态转换逻辑
4. 验证与其他管理器的协作

---

### 第4步：ScoreManager分数管理器

#### 4.4.1 责任人
**用户**

#### 4.4.2 测试用例设计

创建文件：`test/unit/managers/test_score_manager.gd`

```gdscript
extends GutTest

func before_each():
    ScoreManager.reset_score()

func test_add_score():
    # 测试添加分数
    ScoreManager.add_score(100)
    assert_eq(ScoreManager.get_score(), 100)

func test_subtract_score():
    # 测试扣除分数
    ScoreManager.add_score(200)
    ScoreManager.subtract_score(50)
    assert_eq(ScoreManager.get_score(), 150)

func test_high_score():
    # 测试最高分
    ScoreManager.add_score(1000)
    assert_eq(ScoreManager.get_high_score(), 1000)

func test_score_multiplier():
    # 测试分数倍数
    ScoreManager.set_score_multiplier(2.0)
    ScoreManager.add_score(100)
    assert_eq(ScoreManager.get_score(), 200)

func test_extra_life_award():
    # 测试奖励生命
    ScoreManager.add_score(1000)
    # 每1000分奖励一条生命
    assert_signal_emitted(EventBus, "life_changed")
```

#### 4.4.3 实现框架

创建文件：`scripts/managers/score_manager.gd`

```gdscript
extends Node

var current_score: int = 0
var high_score: int = 0
var score_multiplier: float = 1.0

# 添加分数
func add_score(points: int):
    pass  # TODO: 实现分数添加逻辑

# 扣除分数
func subtract_score(points: int):
    pass  # TODO: 实现分数扣除逻辑

# 重置分数
func reset_score():
    pass  # TODO: 实现分数重置逻辑

# 获取当前分数
func get_score() -> int:
    return current_score

# 获取最高分
func get_high_score() -> int:
    return high_score

# 设置分数倍数
func set_score_multiplier(multiplier: float):
    score_multiplier = multiplier
```

#### 4.4.4 用户操作
1. 创建ScoreManager测试文件
2. 实现分数计算逻辑
3. 实现最高分保存
4. 测试分数倍数功能
5. 配置AutoLoad

---

### 第5步：LifeManager生命管理器

#### 4.5.1 责任人
**用户**

#### 4.5.2 测试用例设计

创建文件：`test/unit/managers/test_life_manager.gd`

```gdscript
extends GutTest

func before_each():
    LifeManager.reset_lives()

func test_initial_lives():
    # 测试初始生命值
    assert_eq(LifeManager.get_lives(), 3)

func test_lose_life():
    # 测试失去生命
    LifeManager.lose_life()
    assert_eq(LifeManager.get_lives(), 2)

func test_gain_life():
    # 测试获得生命
    LifeManager.gain_life()
    assert_eq(LifeManager.get_lives(), 4)

func test_max_lives_limit():
    # 测试最大生命值限制
    LifeManager.set_lives(5)
    LifeManager.gain_life()
    assert_eq(LifeManager.get_lives(), 5, "生命值不应超过最大值")

func test_game_over_trigger():
    # 测试游戏结束触发
    LifeManager.set_lives(1)
    LifeManager.lose_life()
    assert_signal_emitted(EventBus, "player_died")

func test_invulnerability_period():
    # 测试无敌时间
    LifeManager.lose_life()
    assert_true(LifeManager.is_invulnerable())
```

#### 4.5.3 实现框架

创建文件：`scripts/managers/life_manager.gd`

```gdscript
extends Node

var current_lives: int = 3
var max_lives: int = 5
var invulnerable_time: float = 2.0
var is_invulnerable_state: bool = false

# 失去生命
func lose_life():
    pass  # TODO: 实现失去生命逻辑

# 获得生命
func gain_life():
    pass  # TODO: 实现获得生命逻辑

# 设置生命值
func set_lives(lives: int):
    pass  # TODO: 实现设置生命值逻辑

# 重置生命值
func reset_lives():
    pass  # TODO: 实现重置生命值逻辑

# 获取当前生命值
func get_lives() -> int:
    return current_lives

# 是否无敌
func is_invulnerable() -> bool:
    return is_invulnerable_state
```

#### 4.5.4 用户操作
1. 创建LifeManager测试文件
2. 实现生命值管理逻辑
3. 实现无敌时间机制
4. 测试游戏结束触发
5. 配置AutoLoad

---

### 第6步：LevelManager关卡管理器

#### 4.6.1 责任人
**用户**

#### 4.6.2 测试用例设计

创建文件：`test/unit/managers/test_level_manager.gd`

```gdscript
extends GutTest

func test_load_level():
    # 测试加载关卡
    LevelManager.load_level("level_01")
    assert_eq(LevelManager.get_current_level(), "level_01")
    assert_true(LevelManager.is_level_loaded())

func test_level_completion():
    # 测试关卡完成
    LevelManager.load_level("level_01")
    LevelManager.complete_level()
    assert_signal_emitted(EventBus, "level_completed", ["level_01"])

func test_unlock_next_level():
    # 测试解锁下一关
    LevelManager.load_level("level_01")
    LevelManager.complete_level()
    assert_true(LevelManager.is_level_unlocked("level_02"))

func test_save_and_load_progress():
    # 测试保存和加载进度
    LevelManager.load_level("level_01")
    LevelManager.set_level_progress(0.75)
    LevelManager.save_progress()
    
    # 新实例测试加载
    var new_manager = LevelManager.new()
    new_manager.load_progress()
    assert_eq(new_manager.get_level_progress(), 0.75)
```

#### 4.6.3 实现框架

创建文件：`scripts/managers/level_manager.gd`

```gdscript
extends Node

var current_level: String = ""
var level_data: Dictionary = {}
var unlocked_levels: Array[String] = ["level_01"]

# 加载关卡
func load_level(level_name: String):
    pass  # TODO: 实现关卡加载逻辑

# 完成关卡
func complete_level():
    pass  # TODO: 实现关卡完成逻辑

# 保存进度
func save_progress():
    pass  # TODO: 实现进度保存逻辑

# 加载进度
func load_progress():
    pass  # TODO: 实现进度加载逻辑

# 是否关卡已解锁
func is_level_unlocked(level_name: String) -> bool:
    return level_name in unlocked_levels
```

#### 4.6.4 用户操作
1. 创建LevelManager测试文件
2. 实现关卡加载逻辑
3. 实现进度保存功能
4. 测试关卡解锁机制
5. 配置AutoLoad

---

### 第7步：AudioManager音频管理器

#### 4.7.1 责任人
**AI助手**

#### 4.7.2 测试用例设计

创建文件：`test/unit/managers/test_audio_manager.gd`

```gdscript
extends GutTest

func test_play_bgm():
    # 测试播放背景音乐
    AudioManager.play_bgm("main_theme")
    assert_eq(AudioManager.get_current_bgm(), "main_theme")

func test_stop_bgm():
    # 测试停止背景音乐
    AudioManager.play_bgm("main_theme")
    AudioManager.stop_bgm()
    assert_eq(AudioManager.get_current_bgm(), "")

func test_play_sfx():
    # 测试播放音效
    AudioManager.play_sfx("jump")
    # 验证音效播放（可能需要mock）

func test_audio_volume_control():
    # 测试音量控制
    AudioManager.set_bgm_volume(0.5)
    assert_eq(AudioManager.get_bgm_volume(), 0.5)
    
    AudioManager.set_sfx_volume(0.7)
    assert_eq(AudioManager.get_sfx_volume(), 0.7)

func test_mute_audio():
    # 测试静音功能
    AudioManager.mute_all()
    assert_true(AudioManager.is_muted())
    
    AudioManager.unmute_all()
    assert_false(AudioManager.is_muted())
```

#### 4.7.3 实现框架

创建文件：`scripts/managers/audio_manager.gd`

```gdscript
extends Node

var bgm_player: AudioStreamPlayer
var sfx_players: Array[AudioStreamPlayer] = []
var bgm_volume: float = 0.8
var sfx_volume: float = 1.0
var is_muted: bool = false

func _ready():
    setup_audio_players()

# 设置音频播放器
func setup_audio_players():
    pass  # TODO: 初始化音频播放器

# 播放背景音乐
func play_bgm(bgm_name: String):
    pass  # TODO: 实现BGM播放逻辑

# 停止背景音乐
func stop_bgm():
    pass  # TODO: 实现BGM停止逻辑

# 播放音效
func play_sfx(sfx_name: String):
    pass  # TODO: 实现SFX播放逻辑

# 设置BGM音量
func set_bgm_volume(volume: float):
    pass  # TODO: 实现BGM音量设置
```

#### 4.7.4 用户操作
1. 创建AudioManager测试文件
2. 实现音频播放控制
3. 测试音量管理功能
4. 配置AutoLoad

---

### 第8步：AutoLoad配置

#### 4.8.1 责任人
**AI助手**

#### 4.8.2 配置步骤

1. 打开项目设置：Project → Project Settings
2. 选择AutoLoad选项卡
3. 按以下顺序添加管理器：

```
[autoload]
EventBus="*res://scripts/managers/event_bus.gd"
ConfigManager="*res://scripts/managers/config_manager.gd"
GameManager="*res://scripts/managers/game_manager.gd"
ScoreManager="*res://scripts/managers/score_manager.gd"
LifeManager="*res://scripts/managers/life_manager.gd"
LevelManager="*res://scripts/managers/level_manager.gd"
AudioManager="*res://scripts/managers/audio_manager.gd"
```

#### 4.8.3 用户操作
1. 在Godot编辑器中配置AutoLoad
2. 验证每个管理器都正确加载
3. 测试全局访问功能

---

## 5. 集成测试

### 5.1 创建测试场景

#### 5.1.1 责任人
**AI助手**

#### 5.1.2 测试场景设计

创建文件：`scenes/managers/manager_test_scene.tscn`

这是一个最小化的测试场景，包含：
- 一个Node作为根节点
- 用于测试管理器交互的脚本

### 5.2 集成测试用例

创建文件：`test/unit/managers/test_manager_integration.gd`

```gdscript
extends GutTest

func test_manager_initialization():
    # 测试管理器初始化
    assert_not_null(EventBus)
    assert_not_null(ConfigManager)
    assert_not_null(GameManager)

func test_game_flow_integration():
    # 测试完整游戏流程
    GameManager.start_new_game()
    ScoreManager.add_score(100)
    LifeManager.lose_life()
    
    assert_eq(GameManager.get_game_state(), GameManager.GameState.PLAYING)
    assert_eq(ScoreManager.get_score(), 100)
    assert_eq(LifeManager.get_lives(), 2)

func test_event_system_integration():
    # 测试事件系统集成
    var life_changed = false
    EventBus.life_changed.connect(func(): life_changed = true)
    
    LifeManager.lose_life()
    assert_true(life_changed, "生命变化事件应该被触发")
```

---

## 6. 测试运行指南

### 6.1 运行所有测试

```bash
# 在项目根目录执行
godot --headless --script scenes/test/test_runner.gd -gdir=res://test/unit/managers/
```

### 6.2 运行特定管理器测试

```bash
# 运行GameManager测试
godot --headless --script scenes/test/test_runner.gd -ginclude=test_game_manager

# 运行多个测试
godot --headless --script scenes/test/test_runner.gd -ginclude=test_game_manager,test_score_manager
```

### 6.3 查看测试覆盖率

```bash
# 生成测试报告
godot --headless --script scenes/test/test_runner.gd -ginclude_subdirs -gjunit_xml_file=test_results.xml
```

---

## 7. 验收标准检查清单

### 7.1 功能验收
- [ ] 所有管理器正确初始化
- [ ] AutoLoad配置成功，全局可访问
- [ ] 事件系统正常工作，管理器间解耦
- [ ] 配置文件正确加载和保存
- [ ] 游戏状态正确管理
- [ ] 分数和生命系统正常工作
- [ ] 关卡加载和进度保存正常

### 7.2 测试验收
- [ ] 所有35个单元测试通过
- [ ] 集成测试通过
- [ ] 测试覆盖率达到70%以上
- [ ] 无测试失败或错误

### 7.3 性能验收
- [ ] 所有管理器初始化时间小于100ms
- [ ] 事件分发延迟小于10ms
- [ ] 内存使用合理，无泄漏

---

## 8. 常见问题和解决方案

### 8.1 AutoLoad循环依赖
**问题**：管理器间循环引用导致初始化失败  
**解决**：使用EventBus解耦，避免直接引用

### 8.2 测试环境隔离
**问题**：测试间相互影响  
**解决**：在before_each中重置管理器状态

### 8.3 配置文件路径
**问题**：配置文件找不到  
**解决**：使用res://和user://正确路径

### 8.4 信号连接
**问题**：信号重复连接导致多次触发  
**解决**：连接前检查是否已连接

---

## 9. 后续优化建议

### 9.1 性能优化
1. 实现对象池管理频繁创建的对象
2. 异步加载大型资源
3. 优化事件分发机制

### 9.2 功能扩展
1. 添加存档槽位管理
2. 实现设置界面
3. 添加成就系统

### 9.3 维护改进
1. 添加日志系统
2. 实现调试工具
3. 完善错误处理

---

## 10. 总结

本指导文档提供了游戏管理器核心框架的完整TDD开发流程，包含：

1. **7个管理器**的详细实现方案
2. **35个测试用例**覆盖核心功能
3. **严格的TDD流程**确保代码质量
4. **明确的分工**（AI助手/用户）
5. **完整的验收标准**

通过遵循此指导文档，您将建立一个健壮、可扩展的游戏管理框架，为后续游戏功能开发奠定坚实基础。

---

## 附录A：文件清单

### A.1 管理器脚本
- `scripts/managers/event_bus.gd`
- `scripts/managers/config_manager.gd`
- `scripts/managers/game_manager.gd`
- `scripts/managers/score_manager.gd`
- `scripts/managers/life_manager.gd`
- `scripts/managers/level_manager.gd`
- `scripts/managers/audio_manager.gd`

### A.2 测试文件
- `test/unit/managers/test_event_bus.gd`
- `test/unit/managers/test_config_manager.gd`
- `test/unit/managers/test_game_manager.gd`
- `test/unit/managers/test_score_manager.gd`
- `test/unit/managers/test_life_manager.gd`
- `test/unit/managers/test_level_manager.gd`
- `test/unit/managers/test_audio_manager.gd`
- `test/unit/managers/test_manager_integration.gd`

### A.3 配置文件
- `configs/game_config.cfg`
- `configs/audio_config.cfg`
- `configs/level_config.cfg`

### A.4 场景文件
- `scenes/managers/manager_test_scene.tscn`

---

## 附录B：命令参考

### B.1 Godot命令
```bash
# 启动编辑器
godot --editor --path .

# 运行测试
godot --headless --script scenes/test/test_runner.gd

# 运行特定场景
godot --path . scenes/test/test_runner.tscn
```

### B.2 GUT测试命令
```bash
# 运行所有测试
godot --headless --script scenes/test/test_runner.gd -gdir=res://test/

# 运行特定目录测试
godot --headless --script scenes/test/test_runner.gd -gdir=res://test/unit/managers/

# 生成测试报告
godot --headless --script scenes/test/test_runner.gd -ginclude_subdirs -gjunit_xml_file=test_results.xml
```

---

**文档完成**

创建日期：2025-12-21  
最后更新：2025-12-21  
文档作者：AI Assistant